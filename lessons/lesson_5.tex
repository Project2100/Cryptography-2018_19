\mychapter{5}{Lesson 5} %181010

This chapter/lesson is devoted in constructing \prg{}s. We begin by assuming to have already a \prg{} $G \in \binary^\lambda \to \binary^{\lambda + 1}$, that extends the string length by one bit, and prove that it is possible to extend such string by an indefinite amount while preserving pseudo-randomness.

\section{Stretching a \prg}

Consider this algorithm that uses $G$ to construct $G^l$, as depicted in figure \ref{fig:gpowerl}:

\begin{enumerate}
    \item Let $s_0 \pickUAR \binary^\lambda$
    \item % AP190904: Ehhhhhhhhh....
    \item $\forall i \in [l(\lambda)]$
    \begin{enumerate}
        \item let $G(s_{i-1}) = (s_i, b_i)$, where $b_i$ is the extra bit generated by a single use of $G$
    \end{enumerate}
    \item Compose $(b_{1}, b_{2}, ..., b_{{l(\lambda)}}, s_{{l(\lambda)}})$. This will be the returned string, which is $\lambda + l(\lambda)$ bits long
\end{enumerate}

\begin{figure}[h]
    \begin{tikzpicture}[node distance = 1.7cm, auto, >=latex']

        \node (a) {};
        \node (b) [box, right of=a, pin={[init]above:$b_{1}$}] {$G$};
        \node (c) [box, right of=b, pin={[init]above:$b_{2}$}] {$G$};
        \node (d) [nobox, right of=c] {$\dots$};
        \node (e) [box, right of=d, pin={[init]above:$b_{i+1}$}] {$G$};
        \node (f) [nobox, right of=e] {$\dots$};
        \node (g) [box, right of=f, pin={[init]above:$b_{l(\lambda)}$}] {$G$};
        \node (h) [right of=g] {};

        \path[->] (a) edge node {$s_{0}$} (b);
        \path[->] (b) edge node {$s_{1}$} (c);
        \path[->] (c) edge node {$s_{2}$} (d);
        \path[->] (d) edge node {$s_{i}$} (e);
        \path[->] (e) edge node {$s_{i+1}$} (f);
        \path[->] (f) edge node {$s_{l(\lambda)-1}$} (g);
        \draw[->] (g) edge node {$s_{l(\lambda)}$} (h);

    \end{tikzpicture}
    \caption{Constructing $G^{l(\lambda)}$ from $G(\lambda)$}
    \label{fig:gpowerl}
\end{figure}

To prove that this construct is a valid \prg, we will make use of a known technique for proving many other results, which relies heavily on reductions like the one employed back in the \owf{} topic, and is commonly called the \emph{``hybrid argument''}.
    
\begin{lemma}[\emph{Hybrid argument}] \label{lem:hybrid}
    Let $X$, $Y$ and $Z$ be three any distribution ensembles of the same length. The following is true:
    \[
        X \compindist Y \wedge Y \compindist Z \implies X \compindist Z
    \] 
\end{lemma}
\begin{proof}
    $\forall \distinguisher \in \ppt$, by using the triangle inequality:
    \begin{align*}
        & |\Pr[\distinguisher(X) = 1] - \Pr[\distinguisher(Z) = 1]| \\
        =\:& |\Pr[\distinguisher(X) = 1] - \Pr[\distinguisher(Y) = 1] + \Pr[\distinguisher(Y) = 1] - \Pr[\distinguisher(Z) = 1]| \\
        \leq\:& |\Pr[\distinguisher(X) = 1] - \Pr[\distinguisher(Y) = 1]| + |\Pr[\distinguisher(Y) = 1] - \Pr[\distinguisher(Z) = 1]| \\
        \leq\:& \nu(n) + \nu'(n)
    \end{align*}
    where $\nu, \nu' \in \negl(n)$. By the sum property of negligible functions, the result is still negligible, proving the lemma.
\end{proof}

In essence, the hybrid argument proves that computational indistinguishability is a transitive relationship, which enables us to design ``hybrid'' games in order to bridge differences two arbitrary ones. This property will be very useful in all future proofs, as it will be shown for the coming theorem:

\begin{theorem}
    If there exists a \prg{} $G(\lambda)$ with one bit stretch, then there exists a \prg{} $G^{l(\lambda)}$ with polynomial stretch relative to its input length:
    \begin{equation*}
        G : \binary^\lambda \to \binary^{\lambda + 1} \implies \forall l(\lambda) \in \poly(\lambda)\ \exists G^l \in \binary^\lambda \to \binary^{\lambda + l(\lambda)} \qedhere
    \end{equation*} 
\end{theorem}

% AP190904: This proof may be overcomplicated
\begin{proof}

    First off, do observe that, since both $G$ and $l$ are polynomial in $\lambda$, then so is $G^{l(\lambda)}$, because it combines $G$ $l(\lambda)$-many times. To prove that $G^{l(\lambda)}$ is indeed a \prg, we will apply the hybrid argument. The hybrids are defined as:
    \begin{itemize}
        \item $H_{\lambda}^{0} := G^{l(\lambda)}(U_{\lambda})$, which is the original construct
        \item $H_{\lambda}^{i} :=
            \begin{cases}
                b_1 , ..., b_{i} \pickUAR \{0,1\} \\
                s_{i} \leftarrow \{0,1\}^{\lambda+i} \\
                (b_{i+1}, ..., b_{l(\lambda)}, s_{l(\lambda)}) := G^{l(\lambda)-i}(s_{i})
            \end{cases}$
        \item $H_{\lambda}^{l(\lambda)} := U_{\lambda + l}$
    \end{itemize}

    Focusing on two subsequent generic hybrids, as shown in figures \ref{fig:prgi} and \ref{fig:prgiplusone}, it can be observed that the only difference between the two resides in how $b_{i + 1}$ is generated: in $H^i$ it comes from an instance of $G$, whereas in $H^{i + 1}$ is chosen at random. $H_\lambda^0$ is the starting point where all bits are pseudorandom, which coincides with the $G^{l(\lambda)}$, and $H_\lambda^{l(\lambda)}$ will generate a totally random string.

    \begin{figure}[ht]

        \begin{tikzpicture}[node distance = 1.9cm, auto, >=latex']

            \node (a) [nobox, pin={[init]above:$b_{1}$}] {};
            \node (c) [nobox, pin={[init]above:$\dots$}] [right of=a,node distance=1cm] {};
            \node (r) [box, pin={[init]above:$b_{i}$}] [right of=c,node distance=1cm] {$U_{\lambda+1}$};
            \node (d) [box, pin={[init]above:$b_{i+1}$}] [right of=r] {$G$};
            \node (e) [box, pin={[init]above:$b_{i+2}$}] [right of=d] {$G$};
            \node (f) [nobox] [right of=e] {$\dots$};
            \node (g) [box, pin={[init]above:$b_{{l(\lambda)}}$}] [right of=f] {$G$};
            \node (h) [right of=g, node distance=2cm]{};

            \path[->] (r) edge node {$s_{i}$} (d);
            \path[->] (d) edge node {$s_{i+1}$} (e);
            \path[->] (e) edge node {$s_{i+2}$} (f);
            \path[->] (f) edge node {$s_{{l(\lambda)}-1}$} (g);
            \path[->] (g) edge node {$s_{{l(\lambda)}}$} (h);

        \end{tikzpicture}

        \caption{$H_{\lambda}^{i}$}
        \label{fig:prgi}

        \begin{tikzpicture}
            \draw[line width=0.2 mm] (0,0) -- (12,0);
        \end{tikzpicture}

        \begin{tikzpicture}[node distance = 1.9cm, auto, >=latex']
            
            \node (a) [nobox, pin={[init]above:$b_{1}$}] {};
            \node (c) [nobox, pin={[init]above:$...$}] [right of=a,node distance=1cm] {};
            \node (r) [box, pin={[init]above:$b_{i}$}] [right of=c,node distance=1cm] {$U_1$};
            \node (d) [box, pin={[init]above:$b_{i+1}$}] [right of=r] {$U_{\lambda+1}$};
            \node (e) [box, pin={[init]above:$b_{i+2}$}] [right of=d] {$G$};
            \node (f) [nobox] [right of=e] {$...$};
            \node (g) [box, pin={[init]above:$b_{l(\lambda)}$}] [right of=f] {$G$};
            \node (h) [right of=g, node distance=2cm]{};

            \path[->] (d) edge node {$s_{i+1}$} (e);
            \path[->] (e) edge node {$s_{i+2}$} (f);
            \path[->] (f) edge node {$s_{{l(\lambda)}-1}$} (g);
            \path[->] (g) edge node {$s_{{l(\lambda)}}$} (h);

        \end{tikzpicture}
        \caption{$H_{\lambda}^{i+1}$}
        \label{fig:prgiplusone}
    \end{figure}

    So let's fix a step $i$ in the gradual substitution, and define the following function $f_i$:

    \begin{equation*}
        f_i(s_{i+1}, b_{i+1}) = (b_1, \dots, b_i, b_{i+1}, b_{i+2}, \dots, b_{l(\lambda)}, s_{l(\lambda)})
    \end{equation*}

    where the first i bits are chosen uniformly at random, and the remaining ones are obtained by subsequent applications of $G$. It can be observed that:

    \begin{itemize}
        \item $f_i(G(U_\lambda))$ has the exact same distribution of $H_\lambda^i$
        \item $f_i(U_{\lambda + 1})$ has the exact same distribution of $H_\lambda^{i + l}$
    \end{itemize}

    Since by \prg{} definition $G(U_\lambda) \compindist U_{\lambda + 1}$, by using the lemma \ref{lem:compmall} we can deduce that $f_i(G(U_\lambda)) \compindist f_{i}(U_{\lambda + 1})$, which in turn, by how $f$ is defined, implies $H^{i} \compindist H^{i + 1}$. This holds for an arbitrary choice of $i$, so by extension:

    \begin{equation*}
        G^{l(\lambda)}(U_\lambda) = H_{\lambda}^{0} \compindist H_{\lambda}^{1} \compindist \dots \compindist H_{\lambda}^{{l(\lambda)}} = U_{\lambda + l(\lambda)}
    \end{equation*}

    which proves that $G^l$ is indeed a \prg.
\end{proof}

\begin{proof}
    \textit{(Contradiction)}: This is an alternate proof that, instead of looking for a function $f$ to model hybrid transitioning, aims for a contradiction.
    
    Suppose $G^l$ is not a \prg; then there must be a point in the hybrid chain $H_\lambda^0 \compindist \dots \compindist H_\lambda^l$ where $H_\lambda^i \not\compindist H_\lambda^{i + 1}$. Thus there exists a distinguisher $\distinguisher^{\textsc{i-th}}$ able to tell apart $H_\lambda^i$ from $H_\lambda^{i + 1}$, as shown in figure \ref{cryptogame:prghybdist}:

    \[
        \exists i \in [0, l], \exists \distinguisher^{\textsc{i-th}} \in \ppt : |\Pr[\distinguisher^{\textsc{i-th}}(H_\lambda^i) = 1] - \Pr[\distinguisher^{\textsc{i-th}}(H_\lambda^{i + 1}) = 1]| \notin \negl(\lambda)
    \]

    \begin{cryptogame}
        {prghybdist}
        {Distinguisher for $H_{\lambda}^{i}$ and $H_{\lambda}^{i+1}$}
        {i-th}

        \receive{\shortstack[l]{
            $Z \pickUAR \{H_{\lambda}^{i}, H_{\lambda}^{i+1}\} \simeq \{0, 1\}$ \\
            $z \pickUAR Z$}}
        {$z = (b_{1}, \dots ,b_{l(\lambda)}, s_{l(\lambda)})$}{}

        \cseqdelay
        
        \send{}{$a$}{\textsc{Output 1 iff} $a \simeq Z$}

    \end{cryptogame}

    If such a distinguisher exists, it can be also used to distinguish an output of $G$ from a $\lambda+1$ uniform string by ``crafting'' a suitable bit sequence, which will distribute exactly as the hybrids in question, as shown in the reduction in figure \ref{cryptoredux:prghyb}. This contradicts the hypothesis of $f$ being a \prg, which by definition is to be indistinguishable from a truly random distribution. Therefore, $G^l$ is indeed a \prg.

    \begin{cryptoredux}
        {prghyb}
        {Reducing to a distinguisher for $G$, where $\beta = (b_1, \dots, b_{i-1})$ and $\sigma = (b_{i+1}, \dots, b_{l(\lambda)}, s_{l(\lambda))}$}
        {prg}
        {i-th}

        \receive{\shortstack[l]{
            $s \pickUAR U_\lambda$ \\
            $z_0 = G(s)$ \\
            $z_1 \pickUAR U_{\lambda+1}$ \\
            $a \pickUAR \{0, 1\}$}}
        {$z_a = (b, s)$}{}

        \cseqdelay

        \invoke{\shortstack[l]{
            $\beta \pickUAR U_{i}$ \\
            $\sigma = G^{l(\lambda)-i+1}(s)$
        }}
        {$(\beta, b, \sigma)$}{}
        
        \cseqdelay

        \return{}{$a'$}{}
        \send{}{$a'$}{\textsc{Output 1 iff} $a' = a$}
    
    \end{cryptoredux}

\end{proof}

\section{Hardcore predicates}

Now that we've seen how to reuse a one-bit stretch \prg{} in order to obtain an arbitrary length of pseudorandom bits, we turn to the problem of constructing a 1-bit stretch \prg{} itself. Let $f$ be a \owf{}, and consider the following questions:
\begin{itemize}
    \item Given an image $f(x)$, which bits of the input $x$ are hard to extract?
    \item Is it always true that, given $f$, the first bit of $f(x)$ is hard to compute for any choice of $x$?
\end{itemize}

\begin{example}
    Given an OWF $f$, then $f'(x) = x_0 || f(x)$ is a OWF.
\end{example}

Two definitions for hardcore predicates are given:

\begin{definition}
    Let $f : \binary^n \to \binary^n$ be a poly-time complex function. A poly-time complex predicate $\hc : \binary^n \to \binary $ is said to be \emph{hard-core} for $f$ iff:
    \[
        \forall \adversary \in \ppt \implies \Pr(\adversary(f(x)) = \hc(x) \knowing x \pickUAR \binary^n) \in \negl(\lambda) 
    \]
\end{definition}

\begin{cryptogame}
    {hcpreddef1}
    {The hardcore game, $f$ and $\hc$ are known}
    {hc(1)}
    \receive{$x \pickUAR \binary^n$}{$f(x)$}{}

    \send{}{$b$}{\textsc{Output 1 iff} $b = \hc(x)$}
\end{cryptogame}

\begin{definition}
    A polynomial time function $\hc : \binary^n \to \binary$ is hard-core for a function $f$ iff:
    \[
        (f(X), h(X)) \compindist (f(X), U_2)
    \]
    where $X$ is a uniform distribution ensemble over $\binary^n$, and $U_2 \sim \unifdist(\binary)$.
\end{definition}


\begin{cryptogame}{hcpreddef2}{Another hardcore game, $f$ and $\mathfrak{hc}$ are known}{hc(2)}
    \cseqdelay
    \receive{\shortstack[l]{
        $x \pickUAR \{0, 1\}^n$ \\
        $z_0 = \mathfrak{hc}(x)$ \\
        $z_1 \pickUAR \{0, 1\}$ \\
        $b \pickUAR \{0, 1\}$
    }}{$(f(x), z_b)$}{}

    \cseqdelay
    \cseqdelay

    \send{}{$b'$}{\textsc{Output 1 iff} $b' = b$}
\end{cryptogame}

% Theorem-as-exercise: The two definitions are equivalent

Having made this definition, some observations are in order: we're going to rule out a cheesy solution

\begin{claim}
    There is no \textit{universal} hardcore predicate $\mathfrak{HC}$ for all functions.
\end{claim}

\begin{proof}
    Suppose there exists such a predicate $\mathfrak{HC}$. Let $f'(x) = \mathfrak{HC}(x) || f(x)$ for a given function $f$. Then $\mathfrak{HC}$ cannot be a hardcore predicate of $f'$, because any image obtained by $f$ reveals the predicate's image itself. This contradicts the universality of $\mathfrak{HC}$.
\end{proof}

However, it is always possible to construct a hardcore predicate for a \owf{}, from another \owf:

\begin{theorem}[Goldreich-Levin, '99]
    Let $f$ be a \owf{} and consider $g(x, r) = (f(x), r)$ for $r \in \binary^n$. Then $g$ is a \owf{}, and:
    \[
        h(x,r) = \left<x, r\right> = \bigxor_{i = 1}^n x_i \xor r_i = \sum_{i = 1}^n x_i \xor r_i \mod 2
    \]
    is hardcore for $g$.
\end{theorem}

\begin{proof}
    \todo{TO BE COMPLETED (...did we actually do this? è una bella menata dimostrare questo)}
\end{proof}

\begin{exercise} \label{ex:owfcomp}
    Prove that $f \in \owf \implies g \in \owf$ (Hint: do a reduction).
\end{exercise}

\begin{solution}[\ref{ex:owfcomp}]
    Let $\distinguisher^{\textsc{g-owf}}$ be a machine that is efficient in inverting $g$, and consider the reduction shown in figure \ref{cryptoredux:owfowf}. By how $g$ is defined, $r'$ must be equal to $r$; therefore $x'$ must be a valid pre-image of $y$ in $f$. This contradicts the property of $f$ being a \owf.

    \begin{cryptoredux}
        {owfowf}
        {Efficiently inverting $f$}
        {f-owf}
        {g-owf}[2]
        
        \receive{\shortstack[l]{
            $x \pickUAR \binary^n$ \\
            $y = f(x)$
        }}{$y$}{}

        \invoke{$r \pickUAR \binary^m$}{$(y, r)$}{}

        \return{}{$(x', r')$}{}

        \send{}{$x'$}{\textsc{Output 1 iff} $f(x') = y$}

    \end{cryptoredux}

\end{solution}

\subsection{One-way permutations}

A \emph{one-way permutation}, or \owp{} in short, is defined exactly as the name itself suggests: a bijective \owf{}.

\[
    f \in \binary^n \leftrightarrow \binary^n \wedge f \in \owf \implies f \in \owp
\]

\begin{corollary}
    If $f \in \binary^n \to \binary^n$ is a \owp{} then, by the theorem of Goldreich-Levin defining $g(), h()$:
    \[
        G(s) = (g(s), h(s))
    \]
    is a \prg.
\end{corollary}

\begin{proof}
    The theorem states that if $f$ is an \owf, then so is $g$. It's trivial to prove the analogue for \owp{}s. Moreover $h$ is hardcore for $g$, tus:
    \begin{align*}
        G(U_{2n}) &\equiv (g(U_{2n}), h(U_{2n})) & \\
        &\equiv (f(U_n), U_n, h(U_{2n})) & \\
        &\compindist (f(U_{n}), U_{n}, U_{1}) & \text{(definition 1 of hardcore predicate)} \\
        &\equiv U_{2n+1} &
    \end{align*}

\end{proof}

We've been successful in constructing a 1-bit stretch \prg; from here, by using the results in the previous section, we can construct a \prg{} that returns binary strings of an arbitrary length that are also pseudo-random.
